- Дата создания: 2022-09-20
- RFC PR: (оставьте изначально пустым)
- RFC Issue: -
- Flexberry Issue: -

# Единый подход к интеграционному тестированию генерируемых из Flexberry Designer приложений

## Краткое описание

Предлагается заложить в генерируемые из Flexberry Designer приложения единый подход, облегчающий быстрый старт и настройку CI/CDL для интеграционного тестирования этих приложений. Рассматривается только случай, когда приложение состоит из фронтенда и бекенда, исходный код которых располагается в одном репозитории, а интеграционные тесты задействуют БД. Сценарии интеграционного тестирования взаимодействия нескольких сервисов или взаимодействия с брокером сообщений выходят за рамки данного RFC.

## Обоснование

Сейчас каждый проект сталкивается с необходимостью самостоятельно придумывать и настраивать автоматизированный запуск интеграционных тестов. Для этого требуется механизм автоматизированного создания БД (либо гарантированной очистки такой БД после прогона тестов), пригодной для осуществления тестовых проверок даже в сценарии с интеграционным тестированием только бекенда. В случае с тестированием взаимодействия фронтенда и бекенда проблема может усложняться необходимостью развертывания где-то бекенда из версии кода, соответствующей текущему тестируемому коммиту. Из-за сложности подобных настроек большинство проектов не используют интеграционное тестирование совсем, либо тестируют очень ограниченные сценарии работы.

## Детальное проектирование

### Требования
Данный RFC предполагает соблюдение следующих требований:
* Фронтенд и бекенд находятся в одном репозитории
* Для запуска сервисов возможно использование docker
* Для выполнения интеграционных тестов необходима подготовленная база данных, содержащая как минимум все необходимые таблицы, а желательно еще и записи в таблицах справочников/реестров/полномочий
* Если PR/MR содержит скрипты изменения БД, они должны применяться на БД, создаваемую для тестов, перед запуском тестов
* После принятия PR/MR, содержащего скрипты изменения БД, для всех последующих запусков тестов должна создаваться БД, на которой эти скрипты уже применены
* Каждый интеграционный тест создает для себя в БД нужное состояние, однако БД общая для разных интеграционных тестов в рамках одного запуска. То есть, если на проекте активировано многопоточное исполнение тестов, код тестов должен предусматривать возможность наличия в БД данных, созданных соседними тестами, и это не должно приводить к падению тестов. После выполнения тест должен удалить из БД свои тестовые данные.
* Параллельно могут выполняться несколько запусков интеграционных тестов, у каждого запуска должна быть своя БД
* Если в тестовом запуске какие-то тесты упали, БД, созданная для этого тестового запуска, не должна удаляться автоматически, чтобы была возможность исследовать состояние, приведшее к падению (*хотя в данном случае гарантий все равно нет, потому что более поздний успешный тест может удалить и данные упавшего*)
* Если все тесты выполнились успешно, БД, созданная для тестирования, должна удаляться
* Интеграционные тесты должно быть можно просто запустить на локальной машине разработчика из IDE (возможно с использованием терминала)

### Описание подхода
1. Для выполнения интеграционного тестирования предлагается использовать отдельный тестовый стенд, а не пытаться запускать контейнеры на машине с агентом сборки. Это позволит уменьшить нагрузку на сервер сборки. Таким образом у прикладного проекта должен быть подготовленный "сервер", на котором будет осуществляться автоматизированное интеграционное тестирование
2. Касательно БД есть два варианта:
   1. **Без Docker**. На подготовленном сервере для интеграционного тестирования есть "эталонная" БД `etalon_db` с нужной схемой таблиц и нужными данными
      1. Командой `CREATE DATABASE %test_db_name% TEMPLATE etalon_db;` создается новая БД с именем, использующим какую-то уникальную для конкретного запуска тестов переменную, чтобы не произошло пересечений с параллельными запусками тестов
      2. На данную БД с помощью psql применяются скрипты, входящие в MR/PR. Если важен порядок применения скриптов, этот порядок должно быть можно обеспечить путем упорядочения файлов со скриптами по наименованию
      3. После принятия PR/MR со скриптами изменения БД запускается автоматический билд, применяющий данные скрипты на `etalon_db`, чтобы при новых запусках БД для тестов уже имела правильную схему и содержимое        
   1. **С Docker**. Во внутреннем docker registry необходим образ PostgreSQL нужной версии с созданной БД для тестов `<internal_registry>/<project_name>/<test_db>:latest`
      1. На подготовленном сервере запускается контейнер с PostgreSQL. При запуске для него создается network с именем, использующим какую-то уникальную для конкретного запуска тестов переменную. Имя контейнера также должно использовать эту переменную, чтобы не произошло пересечений с параллельными запусками тестов. Также необходимо чтобы для контейнера был замапплен уникальный порт из некоторого небольшого диапазона (*размер диапазона определяется исходя из оценки `<возможное кол-во одновременных запусков тестирования> + <возможное кол-во упавших тестовых запусков, находящихся на исправлении>`*). Добиться этого можно взяв `остаток от деления номера билда на размер диапазона + некий стартовый номер порта`
      2. На данную БД с помощью `docker exec -it <container_name> psql` применяются скрипты, входящие в MR/PR. Если важен порядок применения скриптов, этот порядок должно быть можно обеспечить путем упорядочения файлов со скриптами по наименованию
      3. После принятия PR/MR со скриптами изменения БД запускается автоматический билд, собирающий новый образ БД для тестов с примененными скриптами. *Здесь возможен вариант, когда файлы скриптов изменения БД подкладываются прямо в образ и скрипты применяются при запуске контейнера, но это незначительно увеличит время запуска*
    
    > У варианта без Docker на мой взгляд есть преимущество в том, что действия для создания тестовой БД на нем проще как для автоматизации, так и для ручного выполнения. Вариант с Docker при этом выглядит более концептуальным.
3. При запуске интеграционных тестов бекенда (проекты с ними должны содержать в наименовании строку `IntegrationTests`) через переменные среды задается строка подключения к БД для данного тестового запуска. Для тестов бекенда не требуется развертывать какие-то прикладные сервисы на интеграционный стенд
4. При запуске интеграционных тестов фронтенда 
   1. предварительно выполняется сборка докер-образа бекенда из файлов исходной ветки PR/MR `<internal_registry>/<project_name>/<backend>:<build_number>`
   2. образ доставляется на тестовый сервер
   3. запускается контейнер (при использовании варианта БД с Docker, контейнер добавляется в тот же network, что и запущенный контейнер с БД). По правилам аналогичным описанным в пункте 2.2.2 для контейнера маппится определенный порт
   4. в конфиге фронтенда для тестирования задается адрес бекенда, вычисленный на предыдущем шаге. Например, путем подмены в ember-cli-build.js 
   5. запускаются интеграционные тесты фронтенда
   6. после завершения тестов докер-образ бекенда для тестирования удаляется с внутреннего регистратора, чтобы не забивать диск
5. После выполнения тестов проверяется успешность прохождения. Если все тесты пройдены успешно, тестовая БД либо контейнер с тестовой БД удаляются. Если есть упавшие тесты, необходимо обеспечить, чтобы разработчик мог понять какую строку подключения использовать для доступа к БД, использовавшейся для тестов. Самый простой вариант - выводить в лог, но возможно разные CI/CD-инструменты позволяют задавать какие-то значения, видимые в веб-интерфейсе просмотра результатов билда в более явном виде

Данную последовательность шагов предлагается воплотить в виде пайплайна, генерируемого при генерации приложения наряду с файлами бекенда и фронтенда. Варианты пайплайнов реализовать для GitLab и Azure DevOps, поскольку на GitHub отдельный тестовый стенд ожидать как правило не приходится и можно запускать контейнеры прямо на агентах GitHub. Параметры подключения к тестовому серверу, имена образов, диапазоны должны задаваться переменными пайплайна.

Служебные скрипты, например для создания тестовой БД или применения скриптов изменения БД предпочтительно сложить в репозиторий в виде файлов, а не как части пайплайна, чтобы была возможность выполнять их вручную. Для таких скриптов предлагается добавить в набор генерируемых файлов и директорий директорию `.flexberry/scripts`.

## Документирование и обучение

Описание подхода из данного RFC после реализации необходимо будет дополнить деталями относительно возможностей настройки пайплайна на конкретном проекте и опубликовать в виде статьи в документацию по платформе.

## Недостатки
* Небходимо решить какой из вариантов создания тестовой БД использовать или реализовать пайплайны для обоих вариантов
  
## Альтернативы
* Запускать контейнеры с БД и с бекендом можно прямо на агенте сборки. Данный вариант кажется хуже, потому что ресурсы агента ограничены и будет выше шанс влияния соседних билдов
* Можно не иметь постоянно эталонную БД/docker-образ с эталонной БД, а при каждом запуске создавать БД с помощью всех скриптов изменения БД из репозитория. Данный вариант кажется хуже для случая, когда в БД много справочных данных, необходимых для тестирования. В таком случае скрипты заполнения БД данными необходимо хранить в репозитории и применяться на пустую БД они могут существенное время

## Нерешенные вопросы
* Не описано каким образом должны в репозитории располагаться скрипты изменения БД, чтобы их было возможно применять описанным способом
* Не описано каким образом изначально формируется и заполняется справочными данными эталонная БД что для сценария с Docker, что без него