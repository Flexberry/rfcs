- Дата создания: 2018-02-05
- RFC PR:
- RFC Issue:
- Flexberry Issue:

# Универсальный интеграционный адаптер

## Краткое описание

> Необходимо разработать универсальный адаптер для решения задачи интеграции и синхронизации данных корпоративных приложений.

## Обоснование

> Часто на прикладных проектах возникает проблема интеграции/синхронизации данных между несколькими приложениями. В каждом случаи разработчики, задействованные на проекте, с помощью различных технологий и архитектуры, создают свои решения, нацеленные на работу с конкретными приложениями. Отсюда возникает проблема, что при возникновении задачи интеграции, зачастую необходимо начинать разработку интеграционного решения с нуля, из-за невозможности переиспользования или отсутствия других решений. В результате разработке данного проектного решения планируется получить универсальный адаптер, который позволит разработчикам обеспечить интеграцию данных между приложениями с использованием общей технологии и архитектуры.

## Детальное проектирование

> Адаптер должен решать две первичные задачи
-обеспечить интеграцию данных между приложениями
-обеспечить синхронизацию данных между приложениями

Поэтому адаптер должен уметь:
­*формировать запрос на получение данных из других источников;
­*предоставление данных по запросу;
­*получение данных по подписке, и обработка полученных данных;
­*отправка измененных данных в другой источник

Адаптер должен быть кроссплатформенным.
Адаптер должен предоставлять возможность реализации различных способов взаимодействия между приложениями(технологическая шина http://nuget.ics.perm.ru/packages/NewPlatform.Flexberry.HighwaySB,
прямое подлючения БД-приемника и другие).
Адаптер должен предоставлять API для возможности управления из других приложений.

Основная идея - рядом с прикладным приложением разворачивается служба адаптер, которая, при минимальном изменение внутри прикладного проекта-источника, собирает данные об изменениях объктов внутри прикладной системы. 
По запросу или временному регламенту собранные данные передаются приложению приемнику.
За основу реализации синхронизации данных предлагается взять уже разработанный ранее http://nuget.ics.perm.ru/packages/IIS.Synchronizer/, который позволяет реализовать сбор изменений объектов приложения-источника за счет указания интерфейса ISyncObserver и преобразование объектов одной системы в другую - интерфейс ISyncMapper. 


### Описание решения на примере взаимодействия с HighwaySB(http://nuget.ics.perm.ru/packages/NewPlatform.Flexberry.HighwaySB):

####Описание модулей адаптера
![Схема решения](/images/Sync-Adapter-Tech.png)

Адаптер разделен на следующие модули:
1. ASP.NET веб-служба SyncAdapter - отвечает за обработку входящих обращений, регистрацию изменений и формирование из них пакетов, формирование и приём сообщений различных типов.
В службу входят:
*API - Web API содержит методы управляющие поведением адаптера.
*Change Package Collector - Упаковщик фактов-изменений SyncEntity в сообщения для шины SyncLogItem. Содержит логику формирования пакетов сообщений.
*MessageCreator - Формирует для шины наборы сообщений различных типов.
*BusListner - Сохраняет полученные по обратному вызову сообщения от шины в SyncLogItem.

2. Консольное приложение BusSender - отвечает, за обработку подготовленных для отправки SyncLogItem и отправку сообщений в шину.
3. Консольное приложение MessageHandler - отвечает, за обработку полученных SyncLogItem.
4. Sheduler - средство для обращения к Web API для вызова синхронизации по расписанию.
5. Адаптер имеет отдельную от приложения БД, которое содержит таблицы:
*ICS_SyncEntity, ICS_SyncSetting, ICS_SyncSubSetting, ICS_SyncSystem, ICS_SyncType - обеспечивают работу IIS.Synchronizer,
*SyncLogItem - таблица для ведения журнала синхронизации 
*Log - для ведения лога работы модулей,
*KeyMap - таблица соответствия, для хранения возникающих коллизий ключей.
БД является связующим звеном между различными модулями.

####Описание работы адаптера
Изменение в прикладном приложении-источнике App
В приложение-источник App включается сборка в которой создаются наблюдатели(реализация ISyncObserver) за синхронизируемыми объектами. ISyncObserver – паттерн «наблюдатель», обеспечивает реакцию на изменение объекта синхронизации.
Внутри наблюдателя может содержится логика по принятию решения о синхронизации объекта(Например не хотим, что бы при изменении некоторых отдельных полей объект синхронизировался).
Для работы наблюдателя, приложение должно вести аудит изменения своих объектов http://nuget.ics.perm.ru/packages/NewPlatform.Flexberry.Audit. После фиксации аудита изменений(сейчас не реализовано, нужны методы вызывающиеся до и после записи аудита) вызывается соответствующий Observer изменённого объекта,
который записывает факт об изменении объекта - SyncEntity(время, тип объекта, ключ, тип изменения) в специальную таблицу БД ICS_SyncEntity.

ASP.NET веб-служба SyncAdapter
На сервере приложения разворачивается веб-служба адаптер SyncAdapter. К SyncAdapter подключается http://nuget.ics.perm.ru/packages/IIS.Synchronizer/ и сборки объектов приложения-источника App Object и приложений-приемников XML Object и создаются соответствующие сборкам объектов наборы мапперов и наблюдателей.
Для возможности записи изменений при получении изменений из другой системы, а так же для возможности избежать этого, необходимо задать новые наборы наблюдателей.
IIS.Synchronizer позволяет реализовать наборы преобразований объектов из одной системы в другую - мапперы(Реализация ISyncMapper) ISyncMapper – схож с паттерном «адаптер», обеспечивает преобразование объекта системы А в объект системы Б.
Для изменения мастеров используются сабмапперы, настройки их использования прописываются для каждого объекта отдельно. Детейлам соответствуют отдельные мапперы, где агрегатор выступает в роли мастера.
Для преобразования из одного объекта в два используются два разных маппера с одним объектом-источником и разными объектами-приемниками.

IIS.Synchronizer предоставляет интерфейс для сервиса синхронизации ISyncService
Реализации, которого должны обеспечивать следующий функционал:
void SyncObject(ISync value, bool forced = false); - Синхронизация объекта синхронизации.
void PopEntities(); - Сброс метаинформации в хранилище; метаинформация из хранилища считается утвержденной.
void ProceedEntities(bool throwException = false); - Обработка метаинформации находящейся в хранилище.
void SyncType<T>(bool forced = false) where T : ISync; - Формирование метаинформации обо всех объектах класса синхронизации.
Реализация метода ProceedEntities определяет механизм, через который осуществляется связь между приложением-источником и приложеним-приемником, в базовой реализации DefaultSyncService запись изменений осуществляется сразу в БД-приемник.
В данной реализации взаимодейтсвия обработкой SyncEntity будет заниматься модуль Change Package Collector, который будет формировать сообщения для шины.

WEB API
Управление веб-службой SyncAdapter осуществляется за счет средств Web API, гибкость которых позволяет решить проблему интеграции данных между приложениями.
Web API предоставляет методы для возможности синхронизации отдельной сущности(по ключу, по типу) или всех сущностей(все накопившиеся изменения отправить на синхронизацию).
SyncAdapter имеет прямое подключение к БД источника для обработки запросов данных и записи изменений полученных от других приложений.

Change Package Collector
При поступлении внешнего запроса(пользователь в приложении-приемнике нажал кнопку подтянуть справочники) или установленного регламентом времени синхронизации, за заданный период времени,
вычитываются созданные факты-изменения SyncEntity.
Для создания пакетов изменений анализируются факты изменения объектов ICS_SyncEntity за заданные даты. 
1.	Перебираем все факты-изменения из ICS_SyncEntity по дате изменения.
2.	Анализируем факты-изменения, если встретилось, что объект был создан и удалён, то такое изменение не будет включено в сообщение.
Анализируется ситуация повторного включения объекта для синхронизации. Выставляется правильный порядок сообщений в пакете - если объект был создан, то он должен стоять по порядку своей даты создания, если изменён или удалён то в порядке последней дате изменения.
3.	По факту-изменеию вычитывается объкт который был изменён. Сейчас не зависимо от времени изменения, вычитается последнее сохраненное состояние объекта. 
4.	При использовании маппера объект преобразовывается в соответствующий вспомогательный xml-объект, который записывается в сообщение нужного типа. 
5.	Количество записей в одном сообщении не должно превышать заданный параметр, если превысило, то сохраняем пакет как готовое сообщение для шины и формируем второй пакет с сообщением для того же типа. Возможен вариант когда в пакете будет содержатся только одно изменение.
6.	Если обработали все факты-изменения, то сохраняем пакет как готовое сообщение для шины SyncLogItem.

![Схема сообщений](/images/Sync-Adapter-MessageStruct.png)

MessageCreator
MessageCreator - реализует паттерн Фабричный метод и создает XML-сообщения различного типа. После создания пакета формируется XML-сообщение, создаётся SyncLogItem со статусом Prepared и в DataSet сохраняется XML-сообщение.
Для каждого взаимодействия между приложениями создаём свой набор типов сообщений с префиксами направления взаимодействия, вида ToПриемник_fromИсточник_НазваниеЗапроса.

BusListner
При получении сообщения MessageFromESB создаётся запись SyncLogItem со статусом Prepared, в DataSet записывается полученное сообщение, на этом обработчик сообщения шины AcceptMessage заканчивает работу.

BusSender  
По расписанию запускается приложение BusSender, который ищет в таблице SyncLogItem сообщения, готовые к отправке (Direction = Out и статус Prepared), создает MessageForESB и отправляет их в шину. Если шина приняла сообщение (метод SendMessageToESB отработал без исключений), то статус SyncLogItem меняется на Success или на RespWaiting, если сообщение подразумевает получение ответа.
В конце своей обработки BusSender проверяет были ли получены ответы на сообщения со статусом RespWaiting, если период ожидание превысил настраиваемый параметр, то администратору отправляется оповещение.
Если отправка была неуспешной, то в лог производится запись с ошибкой отправки. Если сообщение не может отправиться в течение настраиваемого времени, то высылается оповещение и статус сообщения меняется на Invalid. Отправка не будет работать пока в очереди первое сообщение Invalid.

MessageHandler 
По расписанию запускается MessageHandler, который получает все входящие (Direction = In) SyncLogItem со статусом Prepared и обрабатывает полученное сообщение. После успешной обработки сообщения статус SyncLogItem переводится в Success.
Если обработка прошла неуспешно, тогда сообщению присваивается статус Invalid и обработка останавливается (обработка будет пропускаться пока в очереди первое сообщение Invalid). Производится запись в лог с ошибкой обработки и отправка оповещения.
При получении сообщения смотрим на указанный RequestInfo. Если есть SyncLogItem, со статусом RespWaiting с этим RequestInfo, то обновляем его статус на Success.
Во время обработки записи синхронизации объектов при создания нового объекта может возникнуть коллизия ключей.
Для решения это проблемы предлагается использовать специальную таблицу соответствия ключей - KeyMap(источник, ключ источника, тип, ключ приёмника)


## Документирование и обучение

> Данный раздел заполняется при необходимости. Минимально рекомендуется указать
необходимые изменения в документации платформы.

> Какие определения и термины лучше всего подойдут для объяснения описанного
проектного решения и почему? Как наилучшим образом презентовать описанную
идею - как логическое продолжение используемых в платформе подходов или как
совершенно новую концепцию?

> Должно ли принятие RFC повлечь изменения в структуре или тексте документации?
Затрагивают ли эти измнения подход к обучению пользователей работе с платформой?

> Каким образом проектное решение должно быть представлено для существующих
пользователей платформы?

## Недостатки

> Есть ли причины, почему *не* нужно принимать предложенное проектное решение?
Пожалуйста, хорошо оцените влияние предложенной идеи на обучение платформе, на
интеграцию с существующим и планируемым функционалом, на необходимые изменения
в API и исходном коде существующих приложений, реализованных на базе платформы
и т.п.

> Пожалуйста, попытайтесь идентифицировать необходимые компромисы и последствия 
принятия предложенной идеи.

## Альтернативы

> Существуют ли другие варианты проектного решения? Почему мы не выбрали один из
этих вариантов?

> Каким образом подобные проблемы решаются в других аналогичных платформах,
фреймворках, библиотеках?

## Нерешенные вопросы

> Этот раздел является опциональным, но чаще всего необходим для первых "черновых"
версий RFC. Какие части продложенного проектного решения подлежат дальнейшему
уточнению? Есть ли проблемы, которые однозначно нельзя решить и по которым
требуется принятие окончательного решения после обсуждения?
