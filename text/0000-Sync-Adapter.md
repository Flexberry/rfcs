- Дата создания: 2018-02-05
- RFC PR:
- RFC Issue:
- Flexberry Issue:

# Универсальный интеграционный адаптер

## Краткое описание

> Необходимо разработать универсальный адаптер для решения задачи интеграции и синхронизации данных корпоративных приложений.

## Обоснование

> Часто на прикладных проектах возникает проблема интеграции/синхронизации данных между несколькими приложениями. В каждом случаи разработчики, задействованные на проекте, с помощью различных технологий и архитектуры, создают свои решения, нацеленные на работу с конкретными приложениями. Отсюда возникает проблема, что при возникновении задачи интеграции, зачастую необходимо начинать разработку интеграционного решения с нуля, из-за невозможности переиспользования или отсутствия других решений. В результате разработке данного проектного решения планируется получить универсальный адаптер, который позволит разработчикам обеспечить интеграцию данных между приложениями с использованием общей технологии и архитектуры.

## Детальное проектирование

> Адаптер должен решать две первичные задачи
> * обеспечить интеграцию данных между приложениями
> * обеспечить синхронизацию данных между приложениями

> Адаптер должен обладать следующими возможностями:
> 1. формировать запрос на получение данных из других источников
> 2. предоставление данных по запросу
> 3. получение данных по подписке, и обработка полученных данных
> 4. отправка измененных данных в другой источник
> 5. поддерживать работу в операционных системах Linux и Windows
> 6. предоставлять возможность реализации различных способов взаимодействия между приложениями (сервисная шина предприятия, прямое подключения БД-приёмника и другие)
> 7. предоставлять API для возможности управления из других приложений

> Основная идея - рядом с прикладным приложением разворачивается служба-адаптер, которая, при минимальном изменение внутри прикладного проекта-источника, собирает данные об изменениях объектов внутри прикладной системы. По запросу или временному регламенту собранные данные передаются приложению приёмнику.
> За основу реализации синхронизации данных предлагается взять уже разработанный ранее проект Synchronizer, который позволяет реализовать сбор изменений объектов приложения-источника за счет указания интерфейса ISyncObserver и преобразование объектов одной системы в другую - интерфейс ISyncMapper.


### Описание решения на примере взаимодействия с сервисной шиной предприятия(ESB):

#### Описание модулей адаптера

**Схема решения**
![Схема решения](/Images/SyncAdapter/Sync-Adapter-Tech.png)

> Адаптер разделен на следующие модули:
> 1. ASP.NET веб-служба SyncAdapter - отвечает за обработку входящих обращений, регистрацию изменений и формирование из них пакетов, формирование и приём сообщений различных типов.
> В службу входят:
> * API - Web API содержит методы управляющие поведением адаптера.
> * Change Package Collector - Упаковщик фактов-изменений SyncEntity в сообщения для шины SyncLogItem. Содержит логику по сборке произошедних изменений в пакет.
> * MessageCreator - Формирует для шины наборы сообщений различных типов.
> * BusListener - Сохраняет полученные по обратному вызову сообщения от шины в SyncLogItem.
> 2. Консольное приложение BusSender - отвечает, за обработку подготовленных для отправки SyncLogItem и отправку сообщений в шину.
> 3. Консольное приложение MessageHandler - отвечает, за обработку полученных SyncLogItem.
> 4. Sheduler - средство для обращения к Web API для вызова синхронизации по расписанию.
> 5. Адаптер имеет отдельную от приложения БД, которая является связующим звеном между различными модулями и содержит таблицы:
> * ICS_SyncEntity, ICS_SyncSetting, ICS_SyncSubSetting, ICS_SyncSystem, ICS_SyncType - обеспечивают работу Synchronizer,
> * SyncLogItem - таблица для ведения журнала синхронизации 
> * Log - для ведения лога работы модулей,
> * KeyMap - таблица соответствия, для хранения возникающих коллизий ключей.

#### Описание работы модулей адаптера
**Изменение в прикладном приложении-источнике App**
> В приложение-источник App включается сборка в которой создаются наблюдатели (реализация ISyncObserver) за синхронизируемыми объектами. ISyncObserver – паттерн «наблюдатель», обеспечивает реакцию на изменение объекта синхронизации. Внутри наблюдателя может содержится логика по принятию решения о синхронизации объекта (Например, не хотим, чтобы при изменении некоторых отдельных полей объект синхронизировался).

> Для работы наблюдателя, приложение должно вести аудит изменения своих объектов. После фиксации аудита изменений вызывается соответствующий Observer изменённого объекта, который записывает факт об изменении объекта - SyncEntity(Date, ObjectPrimaryKey, ObjectStatus, Setting) в специальную таблицу БД ICS_SyncEntity.

**ASP.NET веб-служба SyncAdapter**
> На сервере приложения разворачивается веб-служба адаптер SyncAdapter. К SyncAdapter подключается Synchronizer и сборки объектов приложения-источника App Object и приложений-приёмников XML Object и создаются соответствующие сборкам объектов наборы мапперов и наблюдателей.

> Synchronizer позволяет реализовать наборы преобразований объектов из одной системы в другую – мапперы (Реализация ISyncMapper) ISyncMapper – схож с паттерном «адаптер», обеспечивает преобразование объекта системы App в XML-объект для шины. Для изменения мастеров используются сабмапперы, настройки их использования прописываются отдельно. Детейлам соответствуют отдельные мапперы, где агрегатор выступает в роли мастера. Для преобразования из одного объекта в два используются два разных маппера с одним объектом-источником и разными объектами-приёмниками.

> Synchronizer предоставляет интерфейс для сервиса синхронизации ISyncService. Реализации, которого должны обеспечивать следующий функционал:
> * SyncObject - Синхронизация объекта синхронизации.
> * PopEntities - Сброс метаинформации в хранилище; метаинформация из хранилища считается утвержденной.
> * ProceedEntities - Обработка метаинформации находящейся в хранилище.
> * SyncType - Формирование метаинформации обо всех объектах класса синхронизации.
> Реализация метода ProceedEntities определяет механизм, через который осуществляется связь между приложением-источником и приложеним-приёмником, в базовой реализации DefaultSyncService запись изменений осуществляется сразу в БД-приёмник. В данной реализации взаимодействия обработкой SyncEntity будет заниматься модуль Change Package Collector, который будет формировать сообщения для шины.

**WEB API**
> Управление веб-службой SyncAdapter осуществляется за счет средств Web API, гибкость которых позволяет решить проблему интеграции данных между приложениями, создав различные методы для обмена данными. В базовой реализации, Web API предоставляет метод для возможности синхронизации всех сущностей за заданный период (все накопившиеся изменения отправить на синхронизацию). SyncAdapter имеет прямое подключение к БД источника для обработки запросов данных и записи изменений, полученных от других приложений.

**Change Package Collector**
> При поступлении внешнего запроса (пользователь в приложении-приёмнике нажал кнопку подтянуть справочники(время изменений с последней даты отправки по текущее. Последнее время отправки определяется по дате последнего сообщения с типом - отправка изменений)) или установленного регламентом времени синхронизации, за заданный период времени, вычитываются созданные факты-изменения SyncEntity. 
> 1.	Перебираем все факты-изменения из SyncEntity за заданный период. Кол-во вычитанных записей за раз, определяется размерностью пакета. Порядок SyncEntity соответствует порядку в котором были записаны изменения в аудит.
> 2.	По факту-изменению вычитывается изменённый объект. Изменённый объект за счет записей аудита откатывается к состоянию на дату изменения.
> 3.	При использовании маппера объект преобразовывается в соответствующий вспомогательный xml-объект, который записывается в сообщение нужного типа. 
> 4.	Количество записей в одном сообщении не должно превышать заданный параметр, если превысило, то сохраняем пакет как готовое сообщение для шины и формируем второй пакет с сообщением для того же типа. Возможен вариант, когда в пакете будет содержатся только одно изменение.
> 5.	Если обработали все факты-изменения, то сохраняем пакет как готовое сообщение для шины SyncLogItem.

**Схема сообщений**
![Схема сообщений](/Images/SyncAdapter/Sync-Adapter-MessageStruct.png)

**MessageCreator**
> MessageCreator - реализует паттерн Фабричный метод и создает XML-сообщения различного типа. После создания пакета формируется XML-сообщение, создаётся SyncLogItem со статусом Prepared и в DataSet сохраняется XML-сообщение. Для каждого взаимодействия между приложениями создаём свой набор типов сообщений с префиксами направления взаимодействия, вида FromИсточник_НазваниеЗапроса.

**BusListener**
> При получении сообщения из ESB создаётся запись SyncLogItem со статусом Prepared, в DataSet записывается полученное сообщение, на этом обработчик сообщения шины заканчивает работу.

**BusSender** 
> По расписанию запускается приложение BusSender, которое ищет в таблице SyncLogItem сообщения, готовые к отправке (Direction = Out и статус Prepared), создает сообщение для шины и отправляет их. 

> Если шина приняла сообщение, то статус SyncLogItem меняется на Success или на RespWaiting, если сообщение подразумевает получение ответа. В конце своей обработки BusSender проверяет были ли получены ответы на сообщения со статусом RespWaiting, если ответ получен то статус отправленного сообщения меняется на Success, иначе, если был превышен период ожидания ответа, администратору отправляется оповещение.

> Если отправка была неуспешной, то в лог производится запись с ошибкой отправки. Если сообщение не может отправиться в течение настраиваемого времени, то высылается оповещение и статус сообщения меняется на Invalid. Отправка не будет работать пока в очереди первое сообщение Invalid.

**MessageHandler**
> По расписанию запускается MessageHandler, который получает все входящие (Direction = In) SyncLogItem со статусом Prepared и обрабатывает полученное сообщение. После успешной обработки сообщения статус SyncLogItem переводится в Success. Если обработка прошла неуспешно, тогда сообщению присваивается статус Invalid и обработка останавливается (обработка будет пропускаться пока в очереди первое сообщение Invalid). Производится запись в лог с ошибкой обработки и отправка оповещения.

> Во время обработки записи синхронизации объектов при создания нового объекта может возникнуть коллизия ключей. Для решения это проблемы предлагается использовать специальную таблицу соответствия ключей – KeyMap (источник, ключ источника, тип, ключ приёмника)


## Документирование и обучение

> 1. Необходимо будет создать статью по предоставляемым возможностям и использованию этого решения в прикладных проектах.
> 2. В описание Аудита указать возможность применения новых методов. 
> 3. В описании шины добавить ссылку на это решение.

## Недостатки

> Один из возможных недостатков - предложенный шаблон службы-адаптера не будет обладать достаточно гибкой функциональностью, что не позволит решить ряд задач возникающих при интеграции приложений.

## Альтернативы

> Реализация подобных адаптеров за частую является узкоспециализированной для конкретного проектного решения, что не позволяет их использовать в других решениях.

## Нерешенные вопросы

> Проблемы:
> * Пост метод вызывающийся после фиксации изменений аудита. В параметр этому методу должен быть передан изменнённый объект, со статусом произощедшего изменения.
> * Получение состояния объекта на дату, используя аудит-изменения.
> * Механизм Change Package Collector. Возможность отправки разных данных синхронизации, разным приложениям-приемникам.
> * Части которые нужно вынести в общее решение.
> * Механизм разрешения соответствия первичных ключей между различными приложениями.
> * Синхронизация одного и того же объекта сразу несколькими системами-источниками.
