- Дата создания: 2018-02-05
- RFC PR:
- RFC Issue:
- Flexberry Issue:

# Универсальный интеграционный адаптер

## Краткое описание

> Необходимо разработать универсальный адаптер для решения задачи интеграции данных корпоративных приложений.

## Обоснование

> Часто на прикладных проектах возникает проблема интеграции данных между несколькими приложениями и разработчики, задействованные на проекте, с помощью различных технологий и архитектуры, создают свои решения, нацеленные на работу с конкретными приложениями.
>  
> Отсюда вытекает проблема, что при возникновении задачи интеграции, зачастую необходимо начинать разработку решения с нуля, из-за невозможности переиспользования или отсутствия других решений.
>  
> В результате разработки данного проектного решения планируется получить универсальный адаптер, который позволит разработчикам обеспечить интеграцию данных между приложениями с использованием общей технологии и архитектуры.

## Детальное проектирование

> Адаптер должен решать две первичные задачи
> * обеспечить возможность обмена данными между приложениями посредством запросов и ответов
> * обеспечить непрерывную синхронизацию данных между приложениями

> Адаптер должен обладать следующими возможностями:
> 1. формировать запрос на получение данных из других источников
> 2. получать набор данных из другого источника и обрабатывать их
> 3. предоставлять данные по запросу
> 4. отправлять измененные за период данные в другой источник

> Основная идея - рядом с прикладным приложением разворачивается несколько сервисов синхронизации, которые в совокупности обеспечивают необходимую функциональность, при минимальном изменение внутри прикладного проекта-источника. В приложение-источник добавляется сборка с наблюдателями, которые собирают данные об изменениях объектов внутри прикладной системы. По запросу или временному регламенту собранные данные преобразуются и передаются приложению-приёмнику.

> За основу реализации синхронизации взят уже разработанный ранее проект Synchronizer(nuget IIS.Synchronizer), который позволяет реализовать сбор изменений объектов приложения-источника за счет реализованных механизмов наблюдателя - Observer и преобразования объектов одной системы в другую - Mapper.


### Описание решения на прикладном примере взаимодействия с сервисной шиной предприятия(ESB):

#### Описание сервисов синхронизации

**Схема решения**
![Схема решения](/Images/SyncAdapter/Sync-Adapter-Tech.png)

> Описание структуры базы данных синхронизации Sync DB:
> * conformity - соответствие первичных ключей, применяется секционирование по колонкам source и type, заполняется когда обрабатываются входящие синхронизационные сообщения
> * ics_syncentity - факты-изменения, заполняется когда происходит какое-либо изменение отслеживаемых прикладных данных
> * ics_syncsetting - настройки наблюдателей и мапперов
> * ics_syncsubsettings - дополнительные настройки маппинга мастеров
> * ics_syncsystem - настройки сборок объектов, учавствующих в синхронизации
> * ics_synctype - настройки типов объектов, учавствующих в синхронизации
> * objecttype - настройки типов объектов, для которых будет вестись таблица соответствия первичных ключей, заполняется при обработке синхронизационных сообщений
> * source - названия источников входящих сообщений, заполняется при обработке синхронизационных сообщений
> * synclogitem - журнал синхронизации, здесь хранятся входящие и исходящие сообщения

> Сервисы синхронизации делятся на следующие:
> 1. ASP.NET веб-служба SyncAdapter - преобразование объектов из одной системы в другую, регистрацию изменений и формирование из них пакетов синхронизации, а так же формирование и приём сообщений различных типов.
> В службу входят:
> * WEB API - содержит методы управляющие поведением адаптера.
> * Change Package Collector - модуль упаковщика фактов-изменений SyncEntity в сообщения для передачи в систему-приёмник.
> * MessageCreator - модуль формирования различных типов сообщений.
> * BusListener - модуль для получения сообщений из шины. 
> 2. Консольное приложение BusSender - с заданным периодом отправляет готовые сообщения в шину.
> 3. Консольное приложение MessageHandler - отвечает за обработку полученных сообщений с заданным периодом.

> Objects - сборка объектов синхронизатора, поставляется в виде nuget IIS.Synchronization.Objects, используется всеми сервисами.
> 
> Utils - сборка утилит синхронизатора. Содержит различные полезные классы и методы,. Поставляется в виде nuget IIS.Synchronization.Utils, используется всеми сервисами.
> 
> Synchronizer - сборка с общими механизмом маппинга и обсерверов, а так же сервисами для работы с их настройками. Поставляется в виде nuget IIS.Synchronizer.  

#### Описание работы модулей адаптера

**Схема сообщений**
![Схема сообщений](/Images/SyncAdapter/Sync-Adapter-MessageStruct.png)

#### **Изменение в прикладном приложении-источнике App**
> В приложение-источник App включается сборка, в которой создаются наблюдатели (реализация ISyncObserver) за синхронизируемыми объектами. ISyncObserver – паттерн «наблюдатель», обеспечивает реакцию на изменение объекта синхронизации. Внутри наблюдателя может содержится логика по принятию решения о синхронизации объекта (Например, не хотим, чтобы при изменении некоторых отдельных полей объект синхронизировался - делается за счет создания специализируемого представления свойств объекта).

> Для работы наблюдателя, приложение должно вести аудит изменения своих объектов и использовать специализированный сервис аудита SyncAuditService, который поставляется в пакете IIS.Synchronizer. После фиксации аудита изменений вызывается соответствующий Observer изменённого объекта, в результате работы которого записывает факт об изменении объекта - SyncEntity в таблицу БД ics_syncentity.

#### **ASP.NET веб-служба SyncAdapter**
> На сервере приложения разворачивается веб-служба адаптер SyncAdapter. К SyncAdapter подключаются сборки объектов приложения-источника App Object и приложений-приёмников, в данном случаи - XML Object и создаются соответствующие сборкам объектов наборы мапперов.

> IIS.Synchronizer позволяет реализовать наборы преобразований объектов из одной системы в другую – мапперы (Реализация ISyncMapper) ISyncMapper – схож с паттерном «адаптер», обеспечивает преобразование объекта системы App в XML-объект для шины. Для изменения мастеров используются сабмапперы, настройки их использования прописываются отдельно. Детейлам соответствуют отдельные мапперы, где агрегатор выступает в роли мастера. Для преобразования из одного объекта в два используются два разных маппера с одним объектом-источником и разными объектами-приёмниками.

> Управление веб-службой SyncAdapter осуществляется за счет реализации средств Web API, гибкость которых позволяет управлять различными механизмами обмена данных. В базовой реализации, Web API предоставляет метод для возможности синхронизации всех сущностей за заданный период (все накопившиеся изменения отправить на синхронизацию). SyncAdapter имеет прямое подключение к БД источника для обработки запросов данных и записи изменений, полученных от других приложений.

> Для обмена сообщениями с шиной внутри адаптера используется xml-представление передаваемых и принимаемых данных, в виде объектной модели данных - XML Object и объектной модели сообщений XML Message Obj. Используя DataContract сериализатор объектные модели превращаются в xml строку и записываются в тело сообщения для шины.
> Для XML Message Obj определены следующие интерфейсы:
> * ICommonMessage - общий интерфейс для всех типов передаваемых сообщений
> * IDataChangeMessageRequest - интерфейс содержит определение для сообщения-запроса изменений
> * IDataChangeMessageResponse - интерфейс содержит определение для сообщения-ответа с изменениями
> 
> Так же для сообщений определены следующие атрибуты:
> * PackageSize - атрибут для указания размера пакета сообщения
> * SendChangedField - атрибут, который указывает нужно ли в сообщение типа IDataChangeMessageResponse дописывать изменившиеся поля

> Для XML Object определены следующие интерфейсы:
> * IChangedItem - интерфейс содержит определение для передаваемого в сообщении изменения объектов
> * IType - интерфейс содержит определение типа, для запроса изменений по этому типу объектов
> Так же для объектов определены следующие атрибуты:
> * AliasType - атрибут для указания псевдонима типа(Пример: В сообщении-запросе тип может быть указан как "1403", у нас 1403 = Classifier)
> * ForceGetFullChangesType - флаг принудительного полного отката изменений объекта
> * XMLDataFieldType - атрибут для указания, что поле в классе является ссылкой на XML-класс данных. Type указывает на соответствующий тип объектов-источников.

**Процесс отправки синхронизационных сообщений**
![Процесс отправки синхронизационных сообщений](/Images/SyncAdapter/Sync-Adapter-SendSyncMsg.png)

**Change Package Collector**
![Блок схема алгоритма работы упаковщика](/Images/SyncAdapter/Sync-Adapter-ChangePackageCollector.png)

> При поступлении внешнего запроса (произошёл вызов API-метода запускающего синхронизацию) в упаковщик передаются тип сообщения об изменении которое хотим сформировать(IDataChangeMessageResponse) и соответствующие ему объекты (IChangedItem) и далее работа упаковщика происходит по следующиму алгоритму:
> 1.    Вычисление времени с которого брать изменения. Период времени, в который нужно собрать изменения, может быть задан в параметрах упаковщика. Если период времени не задан или дата, с которой планировалось отправить изменения, меньше, чем дата отправки последнего sync-сообщение типа IDataChangeMessageResponse, то время с которого собирать изменения будет переопределено временем ChangesTo последнего сообщения типа IDataChangeMessageResponse. 
> 2.	Вычитываем все факты-изменения SyncEntity за установленный период времени. Количество вычитанных за раз фактов-изменения определяется размерностью пакета PackageSize для сообщения.
> 3.    Перебираем вычитанные факты-изменения. Порядок SyncEntity соответствует порядку в котором были записаны изменения в аудит.
> 4.	По факту-изменению создается изменённый объект. Изменённый объект, с помощью записей аудита, восстанавливается к состоянию на дату изменения.
> 5.    В механизме восстановления учавствуют лишь те поля, мастера и детейлы, которые определены в представление для маппинга. Восстановление объекта может происходит двумя путями, регулируется настройкой в конфиге OnlySelfRollbackFromAudit:
>       * В один проход, при этом на дату изменения будут возвращены только все собственные поля объекта, включая первичные ключи мастеров и детейлов
> 	    * Рекурсивные вызовы, при этом на дату изменения будут возвращены все собственные поля объекта, включая ссылки на мастеров и детейлов, а так же их поля и ссылки>       
> 6.    Восстановленный объект преобразуется, используя соответствующий маппер, в объект для системы-приёмника, в нашем случаи объект из XML Object.
> 7.    Если для типа сообщения установлен атрибут SendChangedField, то в сообщение добавится список изменных полей. 
> 8.	Преобразованный объект добавляется в сообщение типа IDataChangeMessageResponse. Как только обработаются все вычитанные объекты, порция изменений считается обработанной, сформированное сообщение сохраняется, как SyncLogItem готовый к отправке.

**MessageCreator**
> MessageCreator - реализует паттерн "Фабричный метод", для создания исходящих ICommonMessage сообщений различного типа. 
> Основной интерфейс IServiceBusMessageCreator. По-умолчанию содержит реализацию DataChangesCreator для создания сообщений типа IDataChangeMessageRespons. 

**BusListener**
> Сервис слушателя ICallbackSubscriber подключается к шине и ожидает входящих сообщений. Для управлением сервисом слушателя необходимо использовать вспомогательный класс BusListenerServiceHostFactory. 
> При получении сообщения из шины в конфиг файле SyncAdapter ищется привязка между полученным типом сообщения и реализующим его xml-классом(секция serviceBusListener/messageTypes). 
> Далее, если в конфиг файле указан флаг EnableXSDValidation, происходит валидация полученного сообщения соответствующей ему XSD-схемой. 
> Затем полученное сообщение сохраняется в виде записи SyncLogItem со статусом Prepared - готовым к обработке MessageHandler.

#### **BusSender**
![Блок схема алгоритма отправщика сообщения](/Images/SyncAdapter/Sync-Adapter-BlockBusSender.png)
 
> Отправщик сообщений - BusSender подключается к шине IServiceBusService и по таймеру, с определённой переодичностью, отправляет готовые к отправке SyncLogItem(Direction = Out и статус Prepared) в шину. 
> Тип сообщения для шины указывается в SyncLogItem.Description. При отправке сообщения происходит проверка валидности отправляемого сообщения соответствующей ему XSD-схемой, если включён параметр конфига EnableXSDValidation.
> 
> Затем сообщение отправляется в шину и его статус менятеся на Success или RespWaiting, если подразумевается, что это запрос, требующий ответа(заполнено поле SyncLogItem.RequestInfo).
> 
> В случае возникновении ошибки, при отправке сообщения, в лог будет выведено соответствующее оповещение и если сообщение не сможет отправиться за указанное в конфиге время Time, то его статус изменится на Invalid. Отправка не будет работать пока в очереди первое сообщение Invalid.
> 
> В BusSender так же происходит сопоставление запросов и ответов. Для SyncLogItem(Direction = Out и статус RespWaiting) ищутся SyncLogItem(Direction = In) с одинаковым RequestInfo, в случаи нахождения считается что ответ получен и статус RespWaiting меняется на Success. Иначе, если ответ не был получен за указанное в конфиге время ожидания TimeWaitingResponse, то в лог будет выведено предупреждение об этом.

**Процесс обработки сообщений**
![Процесс обработки сообщений](/Images/SyncAdapter/Sync-Adapter-HandleMsg.png)

#### **MessageHandler**
![Блок схема алгоритма обработчика сообщения](/Images/SyncAdapter/Sync-Adapter-MessageHandler.png)

> Обработчик сообщений - MessageHandler по таймеру, с определённой переодичностью, обрабатывает сохранённые SyncLogItem(Direction = In и статус Prepared).
> Для записанного в SyncLogItem.Description типа сообщения в конфиг файле(секция serviceBusListener/messageHandlers) ищется соответствующий сообщению обработчик.
> 
> Затем отрабатывает логика найденного обработчика, в случае не успешной обработки статус SyncLogItem будет переведён в Invalid, в лог записана соответсвующая ошибка и дальнейшая обработка сообщений будет остановлена.
> 
> Для обработки сообщений типа IDataChangeMessageResponse используется специальный обработчик вида IDataMessageHandler, по умолчанию DefaultDataChangeMessageHandler(задается в unity секции), для его инициализации используется класс DataChangeMessageHandlerFactory.

**Описание работы стандартного обработчика DefaultDataChangeMessageHandler**
![Блок схема алгоритма обработчика DefaultDataChangeMessageHandler](/Images/SyncAdapter/Sync-Adapter-BlockSyncMsgHandler.png)

> Определяем тип полученного объекта, пытаясь найти его в таблице ObjectType, если тип не найден, то заносим его туда.
> 
> Определяем занесен ли ключ объекта в таблицу соответствий ключей Сonformity, если соответствие нашлось, то используем ключ приемника pkDest из таблицы соответствий, иначе собственный ключ объекта.
> 
> Если переданный в сообщении объект в состоянии Создан или Изменение
> 
> 1. Ищем этот объект по ключу в прикладной бд.
> 2. Если объект не удалось вычитать по ключу, то пытаемся вычитать его по составному ключу, если такая настройка для него предусмотрена. Настройки составного ключа находятся в мапперах IPropertyMapperWithChangedAttrs.GetAltKey.
> 3. Если не получилось вычитать объект на предыдущих шагах, то создаем его.
> 4. В полученный промежуточный объект устанавливаем значение полей из преобразованного, за счет маппинга, объекта из сообщения.
> 5. Устанавливаем для объекта правильные ссылки на мастеров, с учётом таблицы соответствия ключей.
> 6. Создаём для объекта новое соответствие ключа, если оно не было найдено ранее.
> 
> Если переданный в сообщении объект в состоянии Удалён
> 
> 1. Если для объекта есть запись в таблице Conformity 
> 2. Загружаем все соответствия ключей для данного объекта
> 3. Если соответствий нашлось больше или равно 1, то удаляем запись соответствия найденную в шаге 1
> 4. Если соответствия было найдено ровно 1, то удаляем и сам объект.


## Документирование и обучение

> 1. Необходимо будет создать статью по предоставляемым возможностям и использованию этого решения в прикладных проектах, с описанием общих доступных компонентов и реализаций по умолчанию.
> 2. В описании шины добавить ссылку на это решение.

## Недостатки

> Один из возможных недостатков - предложенный шаблон службы-адаптера не будет обладать достаточно гибкой функциональностью, что не позволит решить ряд задач возникающих при интеграции данных.

## Альтернативы

> Реализация подобных адаптеров за частую является узкоспециализированной для конкретного проектного решения, что не позволяет их использовать в других решениях.

## Нерешенные вопросы

> Проблемы:
> * Разбиение приложений на отдельные общие модули и нугет пакеты.
